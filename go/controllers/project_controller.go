package controllers

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
	"mockapi/dtos"
	"mockapi/models"
	"mockapi/services"
	"mockapi/utils"
)

// ProjectController handles project-related API endpoints.
type ProjectController struct {
	projectService     *services.ProjectService
	randomWordsService *services.RandomWordsService
	requestLogService  *services.RequestLogService
	teamService        *services.TeamService // Added for potential default team logic
}

// NewProjectController creates a new ProjectController.
func NewProjectController(
	ps *services.ProjectService,
	rws *services.RandomWordsService,
	rls *services.RequestLogService,
	ts *services.TeamService,
) *ProjectController {
	return &ProjectController{
		projectService:     ps,
		randomWordsService: rws,
		requestLogService:  rls,
		teamService:        ts,
	}
}

// CreateFreeProject handles POST /project/free
func (pc *ProjectController) CreateFreeProject(c *gin.Context) {
	var dto dtos.CreateProjectDTO
	if err := c.ShouldBindJSON(&dto); err != nil {
		utils.ErrorResponse(c, http.StatusBadRequest, "Invalid request payload: "+err.Error())
		return
	}

	// Validate slug uniqueness if provided, or generate one if not.
	// For this endpoint, slug is required by DTO binding.
	slug := strings.ToLower(*dto.Slug)
	if pc.randomWordsService.IsSlugDisallowed(slug) {
		utils.ErrorResponse(c, http.StatusBadRequest, fmt.Sprintf("Project slug '%s' is disallowed.", slug))
		return
	}

	// Check if project with this slug already exists
	existingProject, err := pc.projectService.GetProjectBySlug(slug)
	if err != nil && err != gorm.ErrRecordNotFound {
		utils.ErrorResponse(c, http.StatusInternalServerError, "Error checking for existing project: "+err.Error())
		return
	}
	if existingProject != nil {
		utils.ErrorResponse(c, http.StatusConflict, fmt.Sprintf("Project with slug '%s' already exists.", slug))
		return
	}

	projectName := slug // Default name to slug if not provided
	if dto.Name != nil && *dto.Name != "" {
		projectName = *dto.Name
	} else {
		projectName = utils.Unslug(slug) // Convert slug to readable name
	}

	description := ""
	if dto.Description != nil {
		description = *dto.Description
	}

	// Handle TeamID. For "free" projects, this might assign to a default public team or user's team.
	// This part needs to align with the application's multi-tenancy model.
	// For now, let's assume a default team or that TeamID is optionally provided.
	var teamID uint = 1 // Placeholder for default team ID
	if dto.TeamID != nil {
		teamID = *dto.TeamID
		// TODO: Validate that teamID exists and user has access to it.
	} else {
		// Potentially fetch a default team using teamService
		// defaultTeam, err := pc.teamService.GetDefaultTeam()
		// if err != nil {
		//    utils.ErrorResponse(c, http.StatusInternalServerError, "Could not assign project to a team: "+err.Error())
		//    return
		// }
		// teamID = defaultTeam.ID
		// For now, hardcoding default team ID as 1 if not provided.
	}


	project := &models.Project{
		Name:        projectName,
		Slug:        slug,
		Description: description,
		TeamID:      teamID, // Assign to the determined team
		// ChannelID will be auto-generated by service if not set
	}

	if err := pc.projectService.CreateProject(project); err != nil {
		utils.ErrorResponse(c, http.StatusInternalServerError, "Failed to create project: "+err.Error())
		return
	}

	utils.SuccessResponse(c, http.StatusCreated, project)
}

// CreateFreeFastForwardProject handles POST /project/free/fast-forward
func (pc *ProjectController) CreateFreeFastForwardProject(c *gin.Context) {
	slug := pc.randomWordsService.GetRandomSlug()
	projectName := utils.Unslug(slug) // Convert slug to readable name

	// Similar to CreateFreeProject, determine TeamID
	var teamID uint = 1 // Placeholder for default team ID
	// Potentially fetch default team using teamService
	// defaultTeam, err := pc.teamService.GetDefaultTeam()
	// if err == nil && defaultTeam != nil {
	// 	teamID = defaultTeam.ID
	// } else {
	// log.Printf("Warning: Could not get default team for fast-forward project: %v", err)
	// }


	project := &models.Project{
		Name:    projectName,
		Slug:    slug,
		TeamID:  teamID, // Assign to the default team
		// ChannelID will be auto-generated by service
	}

	if err := pc.projectService.CreateProject(project); err != nil {
		utils.ErrorResponse(c, http.StatusInternalServerError, "Failed to create fast-forward project: "+err.Error())
		return
	}

	utils.SuccessResponse(c, http.StatusCreated, project)
}

// GetProjectBySlug handles GET /project/:projectSlug
func (pc *ProjectController) GetProjectBySlug(c *gin.Context) {
	projectSlug := c.Param("projectSlug")

	project, err := pc.projectService.GetProjectBySlug(projectSlug)
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			utils.ErrorResponse(c, http.StatusNotFound, fmt.Sprintf("Project with slug '%s' not found.", projectSlug))
		} else {
			utils.ErrorResponse(c, http.StatusInternalServerError, "Failed to retrieve project: "+err.Error())
		}
		return
	}

	// Optionally, fetch related data like request logs
	// For now, just returning the project details.
	// The Java version fetches logs here, but that might be better in a dedicated logs endpoint
	// or paginated if the number of logs can be large.
	// requestLogs, err := pc.requestLogService.GetLogsByProjectID(project.ID, 100, 0) // Example: Get latest 100 logs
	// if err != nil {
	//    log.Printf("Error fetching logs for project %s: %v", projectSlug, err)
	//    // Decide if this error should fail the whole request or just return project without logs
	// }

	// For now, let's match the subtask description and just return project
	// In a real app, you'd structure the response DTO.
	utils.SuccessResponse(c, http.StatusOK, project)
}
